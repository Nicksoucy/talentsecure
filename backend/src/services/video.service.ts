import multer from 'multer';
import path from 'path';
import fs from 'fs';
import { v4 as uuidv4 } from 'uuid';
import { uploadFile, deleteFile, GCS_VIDEO_BUCKET, LOCAL_VIDEO_PATH, useGCS } from '../config/storage';
import {
  uploadVideoToDrive,
  deleteVideoFromDrive,
  useGoogleDrive,
  getEmbedUrl,
} from './googleDrive.service';

/**
 * Multer configuration for video upload
 */

// Ensure the upload directory exists
if (!fs.existsSync(LOCAL_VIDEO_PATH)) {
  fs.mkdirSync(LOCAL_VIDEO_PATH, { recursive: true });
}

// Multer storage configuration
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, LOCAL_VIDEO_PATH);
  },
  filename: (req, file, cb) => {
    // Generate unique filename: uuid_originalname
    const uniqueName = `${uuidv4()}_${file.originalname}`;
    cb(null, uniqueName);
  },
});

// File filter - only allow video files
const fileFilter = (req: any, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  const allowedMimeTypes = [
    'video/mp4',
    'video/mpeg',
    'video/quicktime', // .mov
    'video/x-msvideo', // .avi
    'video/webm',
  ];

  if (allowedMimeTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Format de fichier non supporté. Formats acceptés: MP4, MOV, AVI, WebM'));
  }
};

// Multer configuration
export const videoUpload = multer({
  storage,
  fileFilter,
  limits: {
    fileSize: 500 * 1024 * 1024, // 500 MB max
  },
});

/**
 * Upload video to cloud storage (if enabled) and return the storage path
 */
export async function processVideoUpload(localFilePath: string, originalFilename: string): Promise<string> {
  const fileName = path.basename(localFilePath);

  // Priority: Google Drive > Google Cloud Storage > Local
  if (useGoogleDrive) {
    try {
      console.log('Uploading video to Google Drive...');

      // Upload to Google Drive
      const driveResponse = await uploadVideoToDrive(localFilePath, fileName);

      // Delete local file after successful upload
      if (fs.existsSync(localFilePath)) {
        fs.unlinkSync(localFilePath);
      }

      console.log(`Video uploaded to Google Drive. File ID: ${driveResponse.fileId}`);

      // Return the Google Drive file ID (we'll use this to generate links later)
      return driveResponse.fileId;
    } catch (error: any) {
      console.error('Error uploading video to Google Drive:', error);
      throw new Error(`Failed to upload video to Google Drive: ${error.message}`);
    }
  } else if (useGCS) {
    try {
      // Upload to Google Cloud Storage
      await uploadFile(GCS_VIDEO_BUCKET, localFilePath, fileName);

      // Delete local file after successful upload
      if (fs.existsSync(localFilePath)) {
        fs.unlinkSync(localFilePath);
      }

      console.log(`Video ${fileName} uploaded to GCS and local file deleted`);
    } catch (error) {
      console.error('Error uploading video to GCS:', error);
      throw new Error('Failed to upload video to cloud storage');
    }
  }

  // Return the storage path (filename for GCS/Local, fileId for Drive)
  return fileName;
}

/**
 * Delete video from storage
 */
export async function deleteVideo(videoStoragePath: string): Promise<void> {
  try {
    if (useGoogleDrive) {
      // videoStoragePath is actually the Google Drive file ID
      await deleteVideoFromDrive(videoStoragePath);
      console.log(`Video deleted from Google Drive. File ID: ${videoStoragePath}`);
    } else {
      // GCS or local storage
      await deleteFile(GCS_VIDEO_BUCKET, videoStoragePath);
      console.log(`Video ${videoStoragePath} deleted successfully`);
    }
  } catch (error: any) {
    console.error('Error deleting video:', error);
    throw new Error(`Failed to delete video: ${error.message}`);
  }
}

/**
 * Get video URL for playback
 * Returns different URLs based on storage type
 */
export function getVideoUrl(videoStoragePath: string): string {
  if (useGoogleDrive) {
    // For Google Drive, return embeddable URL
    return getEmbedUrl(videoStoragePath);
  } else {
    // For GCS/local, return standard URL
    // This will be a signed URL generated by the controller
    return videoStoragePath;
  }
}

/**
 * Get video size in MB
 */
export function getVideoSizeInMB(filePath: string): number {
  const stats = fs.statSync(filePath);
  return stats.size / (1024 * 1024);
}
